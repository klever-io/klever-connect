import * as ed from '@noble/ed25519'

import { hexEncode, hexDecode, base64Encode, base64Decode } from '@klever/connect-encoding'
import type { Signature } from './types'

/**
 * Implementation of a cryptographic signature using Ed25519.
 *
 * @remarks
 * This class represents a 64-byte Ed25519 signature generated by signing a message
 * with a private key. Signatures can be verified using the corresponding public key
 * to ensure message authenticity and integrity.
 *
 * Signatures can be encoded in multiple formats:
 * - Hex (hexadecimal string)
 * - Base64 (base64 string)
 * - Raw bytes (Uint8Array)
 *
 * @example
 * ```typescript
 * // Create from hex string
 * const signature = SignatureImpl.fromHex('a1b2c3...')
 *
 * // Create from base64 string
 * const signature = SignatureImpl.fromBase64('YWJjZGVm...')
 *
 * // Create from bytes
 * const signature = SignatureImpl.fromBytes(new Uint8Array(64))
 *
 * // Convert to different formats
 * const hex = signature.toHex()
 * const base64 = signature.toBase64()
 * const bytes = signature.bytes
 * ```
 */
export class SignatureImpl implements Signature {
  constructor(public readonly bytes: Uint8Array) {
    if (bytes.length !== 64) {
      throw new Error('Signature must be 64 bytes')
    }
  }

  get hex(): string {
    return this.toHex()
  }

  toHex(): string {
    return hexEncode(this.bytes)
  }

  toBase64(): string {
    return base64Encode(this.bytes)
  }

  static fromHex(hex: string): SignatureImpl {
    return new SignatureImpl(hexDecode(hex))
  }

  static fromBase64(base64: string): SignatureImpl {
    return new SignatureImpl(base64Decode(base64))
  }

  static fromBytes(bytes: Uint8Array): SignatureImpl {
    return new SignatureImpl(bytes)
  }
}

/**
 * Signs a message asynchronously using Ed25519 cryptography.
 *
 * @remarks
 * This function creates a cryptographic signature that proves the message was signed
 * by the holder of the private key. The signature can be verified by anyone with the
 * corresponding public key to ensure message authenticity and integrity.
 *
 * SECURITY WARNING: Never expose the private key used for signing. Ensure the private
 * key is stored securely and never transmitted over insecure channels.
 *
 * @param message - The message to sign as a Uint8Array (often a transaction hash)
 * @param privateKey - The 32-byte private key used for signing
 * @returns A promise that resolves to a 64-byte signature as a Uint8Array
 *
 * @throws Error if the private key is invalid or signing fails
 *
 * @example
 * ```typescript
 * const message = new TextEncoder().encode('Hello, Klever!')
 * const privateKey = new Uint8Array(32) // Your private key bytes
 *
 * const signatureBytes = await signMessage(message, privateKey)
 *
 * // Convert to SignatureImpl for additional methods
 * const signature = SignatureImpl.fromBytes(signatureBytes)
 * console.log('Signature (hex):', signature.toHex())
 * console.log('Signature (base64):', signature.toBase64())
 * ```
 */
export async function signMessage(
  message: Uint8Array,
  privateKey: Uint8Array,
): Promise<Uint8Array> {
  return ed.signAsync(message, privateKey)
}

/**
 * Signs a message synchronously using Ed25519 cryptography.
 *
 * @remarks
 * This function creates a cryptographic signature that proves the message was signed
 * by the holder of the private key. The signature can be verified by anyone with the
 * corresponding public key to ensure message authenticity and integrity.
 *
 * The synchronous version is provided for environments that don't support async
 * operations, but the async version is generally preferred for better performance.
 *
 * SECURITY WARNING: Never expose the private key used for signing. Ensure the private
 * key is stored securely and never transmitted over insecure channels.
 *
 * @param message - The message to sign as a Uint8Array (often a transaction hash)
 * @param privateKey - The 32-byte private key used for signing
 * @returns A 64-byte signature as a Uint8Array
 *
 * @throws Error if the private key is invalid or signing fails
 *
 * @example
 * ```typescript
 * const message = new TextEncoder().encode('Hello, Klever!')
 * const privateKey = new Uint8Array(32) // Your private key bytes
 *
 * const signatureBytes = signMessageSync(message, privateKey)
 *
 * // Convert to SignatureImpl for additional methods
 * const signature = SignatureImpl.fromBytes(signatureBytes)
 * console.log('Signature (hex):', signature.toHex())
 * ```
 */
export function signMessageSync(message: Uint8Array, privateKey: Uint8Array): Uint8Array {
  return ed.sign(message, privateKey)
}

/**
 * Verifies a signature asynchronously using Ed25519 cryptography.
 *
 * @remarks
 * This function verifies that a signature was created by the holder of the private key
 * corresponding to the given public key. It ensures message authenticity and integrity.
 *
 * Returns true if the signature is valid, false otherwise. This function never throws
 * on invalid signatures - it returns false instead, making it safe to use in validation logic.
 *
 * @param message - The original message that was signed
 * @param signature - The 64-byte signature to verify
 * @param publicKey - The 32-byte public key used for verification
 * @returns A promise that resolves to true if the signature is valid, false otherwise
 *
 * @example
 * ```typescript
 * const message = new TextEncoder().encode('Hello, Klever!')
 * const signatureBytes = new Uint8Array(64) // Signature from signMessage
 * const publicKeyBytes = new Uint8Array(32) // Public key
 *
 * const isValid = await verifySignature(message, signatureBytes, publicKeyBytes)
 *
 * if (isValid) {
 *   console.log('Signature is valid!')
 * } else {
 *   console.log('Invalid signature')
 * }
 * ```
 */
export async function verifySignature(
  message: Uint8Array,
  signature: Uint8Array,
  publicKey: Uint8Array,
): Promise<boolean> {
  try {
    return await ed.verifyAsync(signature, message, publicKey)
  } catch {
    return false
  }
}

/**
 * Verifies a signature synchronously using Ed25519 cryptography.
 *
 * @remarks
 * This function verifies that a signature was created by the holder of the private key
 * corresponding to the given public key. It ensures message authenticity and integrity.
 *
 * The synchronous version is provided for environments that don't support async
 * operations, but the async version is generally preferred for better performance.
 *
 * Returns true if the signature is valid, false otherwise. This function never throws
 * on invalid signatures - it returns false instead, making it safe to use in validation logic.
 *
 * @param message - The original message that was signed
 * @param signature - The 64-byte signature to verify
 * @param publicKey - The 32-byte public key used for verification
 * @returns True if the signature is valid, false otherwise
 *
 * @example
 * ```typescript
 * const message = new TextEncoder().encode('Hello, Klever!')
 * const signatureBytes = new Uint8Array(64) // Signature from signMessageSync
 * const publicKeyBytes = new Uint8Array(32) // Public key
 *
 * const isValid = verifySignatureSync(message, signatureBytes, publicKeyBytes)
 *
 * if (isValid) {
 *   console.log('Signature is valid!')
 * } else {
 *   console.log('Invalid signature')
 * }
 * ```
 */
export function verifySignatureSync(
  message: Uint8Array,
  signature: Uint8Array,
  publicKey: Uint8Array,
): boolean {
  try {
    return ed.verify(signature, message, publicKey)
  } catch {
    return false
  }
}
